<!--
SYNC IMPACT REPORT
==================
Version Change: 1.0.0 → 1.1.0 (MINOR: New principles added)
Ratification: 2025-12-08
Last Amendment: 2025-12-08

Modified Principles: N/A
Added Principles:
  - VI. Standards & Best Practices (frontend, Chrome extensions, AI clients)
  - VII. Simplicity (YAGNI - don't over-design, start simple)

Templates Status:
  ✅ .specify/templates/plan-template.md - Constitution Check section aligned
  ✅ .specify/templates/spec-template.md - Requirements structure compatible
  ✅ .specify/templates/tasks-template.md - Task categorization aligned
  ✅ .specify/templates/checklist-template.md - No changes required
  ✅ .specify/templates/agent-file-template.md - No changes required

Follow-up TODOs:
  - Consider adding linting/formatting tools (ESLint/Prettier) per constitution
  - Set up testing framework (Jest/Vitest) to enforce testing principle
-->

# Web Video Subtitle Browser Extension Constitution

## Core Principles

### I. Security-First (NON-NEGOTIABLE)

API credentials MUST NEVER be exposed in content scripts or client-side code. All
authentication MUST use ephemeral tokens generated by the background script with
automatic expiration and refresh. Token lifetimes MUST be minimized (recommended:
<1 hour). All credential handling code MUST be reviewed before merge.

**Rationale**: Browser extensions run in untrusted environments where content scripts
can be inspected. API key exposure would compromise security and incur financial risk
through API abuse.

### II. Real-time Performance

Audio processing MUST maintain <200ms end-to-end latency (capture to subtitle display).
MediaRecorder chunk sizes MUST be optimized for 100-200ms windows. WebSocket connections
MUST implement automatic reconnection with exponential backoff. Memory leaks from
MediaRecorder or WebSocket sessions are considered critical bugs.

**Rationale**: Real-time subtitle generation requires low latency to maintain user
engagement. Latency >500ms creates noticeable lag that degrades user experience and
makes content difficult to follow.

### III. Browser Compatibility

All features MUST work identically on Chrome/Chromium and Firefox. Browser-specific
code MUST be isolated and documented. WXT framework conventions MUST be followed for
manifest generation and build processes. Platform detection MUST use WXT APIs, not
user-agent sniffing.

**Rationale**: Multi-browser support is a core value proposition. WXT framework provides
cross-browser abstraction; deviating from it creates maintenance burden and compatibility
risks.

### IV. Resource Management

All MediaRecorder instances, WebSocket connections, and audio streams MUST be explicitly
cleaned up on disconnect or navigation. Session timeouts MUST be implemented for inactive
connections (recommended: 5 minutes). Memory usage MUST be profiled for video sessions
>30 minutes. Connection pooling MUST respect Gemini API rate limits (10 concurrent
sessions per project).

**Rationale**: Browser extensions persist across page navigations. Leaked resources
accumulate and degrade browser performance or crash tabs, creating poor user experience.

### V. Privacy & User Consent

Audio capture MUST require explicit user activation (no automatic capture). Users MUST
be able to disable capture per-site via popup controls. Privacy-sensitive sites
(banking, healthcare) MUST be excluded from default permissions. Extension MUST provide
clear indicators when audio capture is active.

**Rationale**: Audio capture is privacy-sensitive. Unexpected or invisible capture
violates user trust and may violate platform policies (Chrome Web Store, Firefox Add-ons).

### VI. Standards & Best Practices

Code MUST follow industry best practices for frontend development, Chrome extension
development, and AI client integrations. React code MUST follow React 19 patterns
(hooks, composition). Chrome extension code MUST follow Manifest V3 guidelines and
WXT framework conventions. AI client code MUST handle streaming responses, error
recovery, and rate limiting appropriately. When best practices conflict, document
the trade-off decision in code comments.

**Rationale**: Following established best practices reduces bugs, improves
maintainability, and ensures compatibility with platform requirements (Chrome Web
Store, Firefox Add-ons). AI integrations have specific reliability patterns
(streaming, retries) that prevent poor user experiences.

### VII. Simplicity (YAGNI)

Start with the simplest solution that solves the immediate requirement. Do NOT
over-design for hypothetical future needs. Do NOT add abstraction layers, design
patterns, or configuration options until a concrete need emerges. If uncertain
whether complexity is needed, ask before implementing. Code reviews MUST challenge
unnecessary complexity.

**Rationale**: Over-engineering increases cognitive load, maintenance burden, and
bug surface area. YAGNI (You Aren't Gonna Need It) principle keeps codebase
accessible and prevents premature optimization. Simple code is easier to modify
when actual requirements emerge.

## Security & Privacy Standards

### API Key Management

- API keys MUST be stored in background script storage only (chrome.storage.local)
- API keys MUST NOT appear in content scripts, console logs, or error messages
- Ephemeral tokens MUST be generated on-demand with minimal scope
- Token refresh MUST occur automatically before expiration
- Failed authentication MUST clear stored tokens and prompt re-entry

### Permissions Policy

- host_permissions MUST be explicitly scoped to supported video sites
- activeTab permission MUST be used for user-initiated actions only
- storage permission MUST encrypt sensitive data where possible
- New permissions MUST be justified in plan.md before implementation

### Audit Requirements

- All code touching credentials MUST be code-reviewed by two developers
- Quarterly security audits MUST review credential handling, permissions, CORS policies
- Penetration testing SHOULD be performed before major releases

## Development Workflow

### Testing Requirements (ASPIRATIONAL)

**Current State**: No testing framework configured.

**Target State**: When testing framework is added (Jest/Vitest recommended):
- Unit tests MUST cover audio processing utilities
- Integration tests MUST cover Gemini API WebSocket lifecycle
- E2E tests SHOULD cover major video sites (YouTube, Netflix)
- Performance tests SHOULD measure latency and memory usage
- Tests MUST pass before merge to main branch

### Code Review Gates

All pull requests MUST include:
- Description of changes and user-facing impact
- Security implications (if touching credentials, permissions, or API calls)
- Browser compatibility verification (tested on Chrome + Firefox)
- Memory/performance impact assessment (for audio processing or UI changes)

### Deployment Phases

1. **Phase 1**: Development builds (yarn dev / yarn dev:firefox)
2. **Phase 2**: Local production builds (yarn build + manual testing)
3. **Phase 3**: Extension store submission (yarn zip → Chrome Web Store / Firefox Add-ons)

### Version Management

Extension version follows manifest.json version field. Increment according to semantic
versioning:
- MAJOR: Breaking changes to user data, API incompatibility, permission changes
- MINOR: New features (new video sites, language support, subtitle styling)
- PATCH: Bug fixes, performance improvements, security patches

## Governance

This constitution supersedes conflicting guidance in code comments, README, or oral
agreements. All feature specifications and implementation plans MUST verify compliance
with these principles.

### Amendment Process

Constitution amendments REQUIRE:
1. Written proposal documenting rationale and impact
2. Approval from project maintainer(s)
3. Migration plan if existing code violates new principles
4. Version increment per semantic versioning rules (see below)

### Versioning Policy

- MAJOR version: Backward-incompatible principle changes (e.g., removing a principle)
- MINOR version: New principles or materially expanded guidance
- PATCH version: Clarifications, wording fixes, non-semantic refinements

### Compliance Review

- All PRs MUST pass Constitution Check in plan-template.md
- Principle violations MUST be justified in Complexity Tracking table
- Quarterly reviews MUST audit compliance and update constitution if outdated

### Runtime Guidance

Use CLAUDE.md for implementation-specific guidance (commands, architecture, development
phases). Constitution defines non-negotiable rules; CLAUDE.md provides tactical guidance.

**Version**: 1.1.0 | **Ratified**: 2025-12-08 | **Last Amended**: 2025-12-08